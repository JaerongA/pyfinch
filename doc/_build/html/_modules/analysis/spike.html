<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>analysis.spike &mdash; pyfinch  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> pyfinch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">pyfinch</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyfinch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>analysis.spike</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for analysis.spike</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for neural analysis</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>


<div class="viewcode-block" id="get_isi"><a class="viewcode-back" href="../../analysis.html#analysis.spike.get_isi">[docs]</a><span class="k">def</span> <span class="nf">get_isi</span><span class="p">(</span><span class="n">spk_ts_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get inter-analysis interval of spikes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spk_ts_list : list</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    isi : class object</span>
<span class="sd">        class object for inter-spike intervals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="n">isi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">spk</span> <span class="ow">in</span> <span class="n">spk_ts_list</span><span class="p">:</span>
        <span class="n">isi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">spk</span><span class="p">))</span>

    <span class="n">isi</span> <span class="o">=</span> <span class="n">ISI</span><span class="p">(</span><span class="n">isi</span><span class="p">)</span>  <span class="c1"># return the class object</span>
    <span class="k">return</span> <span class="n">isi</span></div>


<div class="viewcode-block" id="get_peth"><a class="viewcode-back" href="../../analysis.html#analysis.spike.get_peth">[docs]</a><span class="k">def</span> <span class="nf">get_peth</span><span class="p">(</span><span class="n">evt_ts_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">spk_ts_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
             <span class="n">pre_evt_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">bin_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">nb_bins</span><span class="o">=</span><span class="kc">None</span>
             <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get peri-event histogram &amp; firing rates</span>
<span class="sd">    for song peth event_ts indicates syllable onset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">peth_parm</span>
    <span class="kn">import</span> <span class="nn">copy</span>
    <span class="kn">import</span> <span class="nn">math</span>

    <span class="n">parameter</span> <span class="o">=</span> <span class="n">peth_parm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">pre_evt_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pre_evt_buffer</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bin_size</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">nb_bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nb_bins</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s1">&#39;nb_bins&#39;</span><span class="p">]</span>

    <span class="n">time_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_bins</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">pre_evt_buffer</span>
    <span class="n">peth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">evt_ts_list</span><span class="p">),</span> <span class="n">nb_bins</span><span class="p">))</span>  <span class="c1"># nb of trials x nb of time bins</span>

    <span class="k">for</span> <span class="n">trial_ind</span><span class="p">,</span> <span class="p">(</span><span class="n">evt_ts</span><span class="p">,</span> <span class="n">spk_ts</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">evt_ts_list</span><span class="p">,</span> <span class="n">spk_ts_list</span><span class="p">)):</span>
        <span class="n">spk_ts_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">spk_ts</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">evt_ts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
            <span class="c1"># evt_ts = np.asarray(list(map(float, evt_ts))) + pre_evt_buffer</span>
            <span class="c1"># spk_ts_new -= evt_ts[0]</span>

            <span class="n">evt_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">evt_ts</span><span class="p">)))</span>
            <span class="n">spk_ts_new</span> <span class="o">-=</span> <span class="n">evt_ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">spk_ts_new</span> <span class="o">+=</span> <span class="n">pre_evt_buffer</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">spk_ts_new</span> <span class="o">-=</span> <span class="n">evt_ts</span>
            <span class="n">spk_ts_new</span> <span class="o">+=</span> <span class="n">pre_evt_buffer</span>

        <span class="k">for</span> <span class="n">spk</span> <span class="ow">in</span> <span class="n">spk_ts_new</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">spk</span> <span class="o">/</span> <span class="n">bin_size</span><span class="p">)</span>
            <span class="c1"># print(&quot;spk = {}, bin index = {}&quot;.format(spk, ind))  # for debugging</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Index out of bound&quot;</span><span class="p">)</span>
            <span class="n">peth</span><span class="p">[</span><span class="n">trial_ind</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Truncate the array leaving out only the portion of our interest</span>
    <span class="k">if</span> <span class="n">duration</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="mi">0</span> <span class="o">-</span> <span class="n">pre_evt_buffer</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">time_bin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">time_bin</span> <span class="o">&lt;</span> <span class="n">duration</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">peth</span> <span class="o">=</span> <span class="n">peth</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">time_bin</span> <span class="o">=</span> <span class="n">time_bin</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">peth</span><span class="p">,</span> <span class="n">time_bin</span><span class="p">,</span> <span class="n">parameter</span></div>


<div class="viewcode-block" id="get_pcc"><a class="viewcode-back" href="../../analysis.html#analysis.spike.get_pcc">[docs]</a><span class="k">def</span> <span class="nf">get_pcc</span><span class="p">(</span><span class="n">fr_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get pairwise cross-correlation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fr_array : np.ndarray</span>
<span class="sd">        trial x time_bin</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pcc_dict : dict</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pcc_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">pcc_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">for</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">fr1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fr_array</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ind2</span><span class="p">,</span> <span class="n">fr2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fr_array</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ind2</span> <span class="o">&gt;</span> <span class="n">ind1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">((</span><span class="n">fr1</span> <span class="o">-</span> <span class="n">fr1</span><span class="o">.</span><span class="n">mean</span><span class="p">()),</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">((</span><span class="n">fr2</span> <span class="o">-</span> <span class="n">fr2</span><span class="o">.</span><span class="n">mean</span><span class="p">()),</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">fr1</span><span class="p">,</span> <span class="n">fr2</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
                        <span class="n">pcc_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pcc_arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">fr1</span><span class="p">,</span> <span class="n">fr2</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># get correlation coefficient</span>

    <span class="n">pcc_dict</span><span class="p">[</span><span class="s1">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcc_arr</span>
    <span class="n">pcc_dict</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">pcc_arr</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pcc_dict</span></div>


<div class="viewcode-block" id="jitter_spk_ts"><a class="viewcode-back" href="../../analysis.html#analysis.spike.jitter_spk_ts">[docs]</a><span class="k">def</span> <span class="nf">jitter_spk_ts</span><span class="p">(</span><span class="n">spk_ts_list</span><span class="p">,</span> <span class="n">shuffle_limit</span><span class="p">,</span> <span class="n">reproducible</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a random temporal jitter to the spike</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reproducible : bool</span>
<span class="sd">        make the results reproducible by setting the seed as equal to index</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="n">spk_ts_jittered_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">spk_ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spk_ts_list</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">reproducible</span><span class="p">:</span>  <span class="c1"># randomization seed</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">ind</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>  <span class="c1"># make random jitter reproducible</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spk_ts_list</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>  <span class="c1"># make random jitter reproducible</span>
        <span class="n">nb_spk</span> <span class="o">=</span> <span class="n">spk_ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">shuffle_limit</span><span class="p">,</span> <span class="n">shuffle_limit</span><span class="p">,</span> <span class="n">nb_spk</span><span class="p">)</span>
        <span class="n">spk_ts_jittered_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_ts</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spk_ts_jittered_list</span></div>


<div class="viewcode-block" id="pcc_shuffle_test"><a class="viewcode-back" href="../../analysis.html#analysis.spike.pcc_shuffle_test">[docs]</a><span class="k">def</span> <span class="nf">pcc_shuffle_test</span><span class="p">(</span><span class="n">ClassObject</span><span class="p">,</span> <span class="n">PethInfo</span><span class="p">,</span> <span class="n">plot_hist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run statistical test to see if baseline pairwise cross-correlation obtained by spike time shuffling</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ClassObject : class object (e.g., NoteInfo, MotifInfo)</span>
<span class="sd">    PethInfo : peth info class object</span>
<span class="sd">    plot_hist : bool</span>
<span class="sd">        Plot histogram of bootstrapped pcc values (False by default)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    p_sig : dict</span>
<span class="sd">        True if the pcc is significantly above the baseline</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">peth_shuffle</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
    <span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="n">pcc_shuffle</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">peth_shuffle</span><span class="p">[</span><span class="s1">&#39;shuffle_iter&#39;</span><span class="p">]):</span>
        <span class="n">ClassObject</span><span class="o">.</span><span class="n">jitter_spk_ts</span><span class="p">(</span><span class="n">peth_shuffle</span><span class="p">[</span><span class="s1">&#39;shuffle_limit&#39;</span><span class="p">])</span>
        <span class="n">pi_shuffle</span> <span class="o">=</span> <span class="n">ClassObject</span><span class="o">.</span><span class="n">get_note_peth</span><span class="p">(</span><span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># peth object</span>
        <span class="n">pi_shuffle</span><span class="o">.</span><span class="n">get_fr</span><span class="p">()</span>  <span class="c1"># get firing rates</span>
        <span class="n">pi_shuffle</span><span class="o">.</span><span class="n">get_pcc</span><span class="p">()</span>  <span class="c1"># get pcc</span>
        <span class="k">for</span> <span class="n">context</span><span class="p">,</span> <span class="n">pcc</span> <span class="ow">in</span> <span class="n">pi_shuffle</span><span class="o">.</span><span class="n">pcc</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pcc_shuffle</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pcc_shuffle</span><span class="p">[</span><span class="n">context</span><span class="p">],</span> <span class="n">pcc</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">])</span>

    <span class="c1"># One-sample t-test (one-sided)</span>
    <span class="n">p_val</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">p_sig</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">pcc_shuffle</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">p_val</span><span class="p">[</span><span class="n">context</span><span class="p">])</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">ttest_1samp</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">pcc_shuffle</span><span class="p">[</span><span class="n">context</span><span class="p">],</span> <span class="n">popmean</span><span class="o">=</span><span class="n">PethInfo</span><span class="o">.</span><span class="n">pcc</span><span class="p">[</span><span class="n">context</span><span class="p">][</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span>
                                                <span class="n">nan_policy</span><span class="o">=</span><span class="s1">&#39;omit&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;less&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">context</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">p_val</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">p_sig</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">alpha</span>

    <span class="c1"># Plot histogram</span>
    <span class="k">if</span> <span class="n">plot_hist</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">..utils.draw</span> <span class="kn">import</span> <span class="n">remove_right_top</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;PCC shuffle distribution&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=.</span><span class="mi">98</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">pcc_shuffle</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">pcc_shuffle</span><span class="p">[</span><span class="n">context</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;PCC&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p_sig</span><span class="p">[</span><span class="n">context</span><span class="p">]:</span>
                <span class="n">axis</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">PethInfo</span><span class="o">.</span><span class="n">pcc</span><span class="p">[</span><span class="n">context</span><span class="p">][</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axis</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">PethInfo</span><span class="o">.</span><span class="n">pcc</span><span class="p">[</span><span class="n">context</span><span class="p">][</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
            <span class="n">remove_right_top</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">p_sig</span></div>


<div class="viewcode-block" id="ClusterInfo"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo">[docs]</a><span class="k">class</span> <span class="nc">ClusterInfo</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel_nb</span><span class="p">,</span> <span class="n">unit_nb</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;rhd&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">time_unit</span><span class="o">=</span><span class="s1">&#39;ms&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load information about cluster</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : path</span>
<span class="sd">            path that contains recording files for the cluster</span>
<span class="sd">        channel_nb : int</span>
<span class="sd">            number of the channel that recorded the cluster</span>
<span class="sd">        unit_nb : int</span>
<span class="sd">            number id of the cluster (needed because multiple neurons could have been recorded in the same session &amp; channel)</span>
<span class="sd">        format : str</span>
<span class="sd">            &#39;rhd&#39; by default (Intan)</span>
<span class="sd">        name : name of the cluster</span>
<span class="sd">            e.g., (&#39;096-g70r40-Predeafening-D07(20191106)-S03-Ch17-Cluster01&#39;)</span>
<span class="sd">        update : bool</span>
<span class="sd">            If not exists, create a .npz cache file in the same folder so that it doesn&#39;t read from the raw data every time the class is called.</span>
<span class="sd">        time_unit : str</span>
<span class="sd">            &#39;ms&#39; by default</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.load</span> <span class="kn">import</span> <span class="n">load_song</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="k">if</span> <span class="n">channel_nb</span><span class="p">:</span>  <span class="c1"># if a neuron was recorded</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">channel_nb</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span> <span class="o">=</span> <span class="s1">&#39;Ch0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">channel_nb</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">channel_nb</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span> <span class="o">=</span> <span class="s1">&#39;Ch&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">channel_nb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span> <span class="o">=</span> <span class="s1">&#39;Ch&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unit_nb</span> <span class="o">=</span> <span class="n">unit_nb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="nb">format</span>

        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_print_name</span><span class="p">()</span>

        <span class="c1"># Load events</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">/</span> <span class="s2">&quot;ClusterInfo_</span><span class="si">{}</span><span class="s2">_Cluster</span><span class="si">{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_nb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">file_name</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>  <span class="c1"># if .npy doesn&#39;t exist or want to update the file</span>
            <span class="n">song_info</span> <span class="o">=</span> <span class="n">load_song</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="c1"># Save cluster_info as a numpy object</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">song_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">song_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="c1"># Set the dictionary values to class attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">song_info</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">song_info</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="c1"># Load spike</span>
        <span class="k">if</span> <span class="n">channel_nb</span> <span class="ow">and</span> <span class="n">unit_nb</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_spk</span><span class="p">(</span><span class="n">time_unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># print attributes</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

    <span class="k">def</span> <span class="nf">_print_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Load cluster </span><span class="si">{self.name}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="ClusterInfo.list_files"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo.list_files">[docs]</a>    <span class="k">def</span> <span class="nf">list_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">list_files</span>

        <span class="k">return</span> <span class="n">list_files</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_load_spk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_unit</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load spike information</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_unit : str</span>
<span class="sd">            time unit (e.g., &#39;ms&#39;)</span>
<span class="sd">        delimiter : str</span>
<span class="sd">            delimiter of the cluster file (tab (\t) by default)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            sets spk_wf, spk_ts, nb_spk as attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">spk_txt_file</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span> <span class="o">+</span> <span class="s1">&#39;(merged).txt&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">spk_txt_file</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;spk text file doesn&#39;t exist !&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">spk_txt_file</span> <span class="o">=</span> <span class="n">spk_txt_file</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">spk_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">spk_txt_file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># skip header</span>

        <span class="c1"># Select only the unit (there could be multiple isolated units in the same file)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_nb</span><span class="p">:</span>  <span class="c1"># if the unit number is specified</span>
            <span class="n">spk_info</span> <span class="o">=</span> <span class="n">spk_info</span><span class="p">[</span><span class="n">spk_info</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_nb</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">spk_ts</span> <span class="o">=</span> <span class="n">spk_info</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># analysis time stamps</span>
        <span class="n">spk_wf</span> <span class="o">=</span> <span class="n">spk_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>  <span class="c1"># analysis waveform</span>
        <span class="n">nb_spk</span> <span class="o">=</span> <span class="n">spk_wf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># total number of spikes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spk_wf</span> <span class="o">=</span> <span class="n">spk_wf</span>  <span class="c1"># individual waveforms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_spk</span> <span class="o">=</span> <span class="n">nb_spk</span>  <span class="c1"># the number of spikes</span>

        <span class="c1"># Units are in second by default, but convert to  millisecond with the argument</span>
        <span class="k">if</span> <span class="n">time_unit</span> <span class="o">==</span> <span class="s1">&#39;ms&#39;</span><span class="p">:</span>
            <span class="n">spk_ts</span> <span class="o">*=</span> <span class="mf">1E3</span>

        <span class="c1"># Output analysis timestamps per file in a list</span>
        <span class="n">spk_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">file_start</span><span class="p">,</span> <span class="n">file_end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_end</span><span class="p">):</span>
            <span class="n">spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_ts</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">spk_ts</span> <span class="o">&gt;=</span> <span class="n">file_start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spk_ts</span> <span class="o">&lt;=</span> <span class="n">file_end</span><span class="p">))])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span> <span class="o">=</span> <span class="n">spk_list</span>  <span class="c1"># analysis timestamps in ms</span>
        <span class="c1"># print(&quot;spk_ts, spk_wf, nb_spk attributes added&quot;)</span>

<div class="viewcode-block" id="ClusterInfo.analyze_waveform"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo.analyze_waveform">[docs]</a>    <span class="k">def</span> <span class="nf">analyze_waveform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">align_wf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interp_factor</span><span class="o">=</span><span class="kc">None</span>
                         <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform waveform analysis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        align_wf : bool</span>
<span class="sd">            align all spike waveforms relative to the max location</span>
<span class="sd">        interpolate : bool</span>
<span class="sd">            Set to true if waveform interpolation is needed</span>
<span class="sd">        interp_factor : int</span>
<span class="sd">            Factor by which to increase the sampling frequency of the waveform</span>
<span class="sd">            e.g., 100 if you want to increase the data points by 100 fold</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.functions</span> <span class="kn">import</span> <span class="n">align_waveform</span><span class="p">,</span> <span class="n">get_half_width</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">sample_rate</span>

        <span class="k">if</span> <span class="n">align_wf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spk_wf</span> <span class="o">=</span> <span class="n">align_waveform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_wf</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_get_spk_profile</span><span class="p">(</span><span class="n">wf_ts</span><span class="p">,</span> <span class="n">avg_wf</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span><span class="p">):</span>
            <span class="n">spk_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">avg_wf</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">avg_wf</span><span class="p">))</span>  <span class="c1"># in microseconds</span>
            <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="n">spk_width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">avg_wf</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">avg_wf</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">])</span> <span class="o">/</span> <span class="n">interp_factor</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1E6</span>  <span class="c1"># in microseconds</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spk_width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">avg_wf</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">avg_wf</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1E6</span>  <span class="c1"># in microseconds</span>
            <span class="n">deflection_range</span><span class="p">,</span> <span class="n">half_width</span> <span class="o">=</span> <span class="n">get_half_width</span><span class="p">(</span><span class="n">wf_ts</span><span class="p">,</span> <span class="n">avg_wf</span><span class="p">)</span>  <span class="c1"># get the half width from the peak deflection</span>
            <span class="k">return</span> <span class="n">spk_height</span><span class="p">,</span> <span class="n">spk_width</span><span class="p">,</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">deflection_range</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">interp_factor</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">interp_factor</span>
            <span class="n">interp_factor</span> <span class="o">=</span> <span class="n">interp_factor</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">avg_wf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_wf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wf_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">avg_wf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1E3</span>  <span class="c1"># x-axis in ms</span>

        <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>  <span class="c1"># interpolate the waveform to increase sampling frequency</span>
            <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>

            <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wf_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">avg_wf</span><span class="p">)</span>
            <span class="n">wf_ts_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wf_ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">wf_ts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">wf_ts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">interp_factor</span><span class="p">)))</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">wf_ts_interp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">interp_factor</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wf_ts</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">avg_wf_interp</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">wf_ts_interp</span><span class="p">)</span>  <span class="c1"># use interpolation function returned by `interp1d`</span>

            <span class="c1"># Replace the original value with interpolated ones</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wf_ts_interp</span> <span class="o">=</span> <span class="n">wf_ts_interp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">avg_wf_interp</span> <span class="o">=</span> <span class="n">avg_wf_interp</span>

            <span class="n">spk_height</span><span class="p">,</span> <span class="n">spk_width</span><span class="p">,</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">deflection_range</span> <span class="o">=</span> <span class="n">_get_spk_profile</span><span class="p">(</span><span class="n">wf_ts_interp</span><span class="p">,</span> <span class="n">avg_wf_interp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spk_height</span><span class="p">,</span> <span class="n">spk_width</span><span class="p">,</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">deflection_range</span> <span class="o">=</span> <span class="n">_get_spk_profile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wf_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">avg_wf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spk_height</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">spk_height</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># in microvolts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_width</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">spk_width</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># in microseconds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">half_width</span> <span class="o">=</span> <span class="n">half_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deflection_range</span> <span class="o">=</span> <span class="n">deflection_range</span>  <span class="c1"># the range where half width was calculated</span></div>

        <span class="c1"># print(&quot;avg_wf, spk_height (uv), spk_width (us), wf_ts (ms) added&quot;)</span>

<div class="viewcode-block" id="ClusterInfo.get_conditional_spk"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo.get_conditional_spk">[docs]</a>    <span class="k">def</span> <span class="nf">get_conditional_spk</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get spike timestamps from different contexts&quot;&quot;&quot;</span>
        <span class="n">conditional_spk</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">conditional_spk</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_ts</span> <span class="k">for</span> <span class="n">spk_ts</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">]</span>
        <span class="n">conditional_spk</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_ts</span> <span class="k">for</span> <span class="n">spk_ts</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">conditional_spk</span></div>

<div class="viewcode-block" id="ClusterInfo.get_correlogram"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo.get_correlogram">[docs]</a>    <span class="k">def</span> <span class="nf">get_correlogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_spk_list</span><span class="p">,</span> <span class="n">target_spk_list</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get auto- or cross-correlogram&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">spk_corr_parm</span>
        <span class="kn">import</span> <span class="nn">math</span>

        <span class="n">correlogram</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">social_context</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">):</span>
            <span class="c1"># Compute spk correlogram</span>
            <span class="n">corr_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;time_bin&#39;</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">ref_spks</span><span class="p">,</span> <span class="n">target_spks</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ref_spk_list</span><span class="p">,</span> <span class="n">target_spk_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="n">social_context</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ref_spk</span> <span class="ow">in</span> <span class="n">ref_spks</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">target_spk</span> <span class="ow">in</span> <span class="n">target_spks</span><span class="p">:</span>
                            <span class="n">diff</span> <span class="o">=</span> <span class="n">target_spk</span> <span class="o">-</span> <span class="n">ref_spk</span>  <span class="c1"># time difference between two spikes</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;=</span> <span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]):</span>
                                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;time_bin&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)))[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                <span class="k">elif</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;time_bin&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">diff</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                                <span class="c1"># print(&quot;diff = {}, bin index = {}&quot;.format(diff, spk_corr_parm[&#39;time_bin&#39;][ind]))  # for debugging</span>
                                <span class="n">corr_temp</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># Make sure the array is symmetrical</span>
                    <span class="n">first_half</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">([</span><span class="n">corr_temp</span><span class="p">[:</span><span class="nb">int</span><span class="p">((</span><span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">]))]])[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">second_half</span> <span class="o">=</span> <span class="n">corr_temp</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
                    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">first_half</span> <span class="o">-</span> <span class="n">second_half</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

                    <span class="c1"># Normalize correlogram by the total sum (convert to probability density )</span>
                    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                        <span class="n">corr_temp</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">correlogram</span><span class="p">)</span>

            <span class="n">correlogram</span><span class="p">[</span><span class="n">social_context</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr_temp</span>
        <span class="n">correlogram</span><span class="p">[</span><span class="s1">&#39;parameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spk_corr_parm</span>  <span class="c1"># store parameters in the dictionary</span>

        <span class="k">return</span> <span class="n">correlogram</span></div>

<div class="viewcode-block" id="ClusterInfo.jitter_spk_ts"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo.jitter_spk_ts">[docs]</a>    <span class="k">def</span> <span class="nf">jitter_spk_ts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shuffle_limit</span><span class="p">,</span> <span class="n">reproducible</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a random temporal jitter to the spike</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shuffle_limit : int</span>
<span class="sd">            shuffling limit (in ms)</span>
<span class="sd">            e.g., If set to 5, any integer values between -5 to 5 drawn from uniform distribution will be added to the spike timestamp</span>
<span class="sd">        reproducible : bool</span>
<span class="sd">            make the results reproducible by setting the seed as equal to index</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">spk_ts_jittered_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">spk_ts</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">reproducible</span><span class="p">:</span>  <span class="c1"># randomization seed</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="n">ind</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>  <span class="c1"># make random jitter reproducible</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>  <span class="c1"># make random jitter reproducible</span>
            <span class="n">nb_spk</span> <span class="o">=</span> <span class="n">spk_ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">shuffle_limit</span><span class="p">,</span> <span class="n">shuffle_limit</span><span class="p">,</span> <span class="n">nb_spk</span><span class="p">)</span>
            <span class="n">spk_ts_jittered_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_ts</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_jittered</span> <span class="o">=</span> <span class="n">spk_ts_jittered_list</span></div>

<div class="viewcode-block" id="ClusterInfo.get_jittered_corr"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo.get_jittered_corr">[docs]</a>    <span class="k">def</span> <span class="nf">get_jittered_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get correlogram based time-jittered spikes&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">corr_shuffle</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

        <span class="n">correlogram_jitter</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">corr_shuffle</span><span class="p">[</span><span class="s1">&#39;shuffle_iter&#39;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jitter_spk_ts</span><span class="p">(</span><span class="n">corr_shuffle</span><span class="p">[</span><span class="s1">&#39;shuffle_limit&#39;</span><span class="p">])</span>
            <span class="n">corr_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_correlogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_jittered</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_jittered</span><span class="p">)</span>
            <span class="c1"># Combine correlogram from two contexts</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">corr_temp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s1">&#39;parameter&#39;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">correlogram_jitter</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">correlogram_jitter</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># Convert to array</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">correlogram_jitter</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">correlogram_jitter</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">correlogram_jitter</span></div>

<div class="viewcode-block" id="ClusterInfo.get_isi"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo.get_isi">[docs]</a>    <span class="k">def</span> <span class="nf">get_isi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_premotor_spk</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get inter-spike interval</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        add_premotor_spk : bool</span>
<span class="sd">            add spikes from the premotor window for calculation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="n">isi_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">list_zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">add_premotor_spk</span><span class="p">:</span>
            <span class="c1"># Include spikes from the pre-motif buffer for calculation</span>
            <span class="c1"># Pre-motor spikes are included in spk_list by default</span>
            <span class="n">spk_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">onset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">spks</span> <span class="ow">in</span> <span class="n">list_zip</span><span class="p">:</span>
                <span class="n">onset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">onset</span><span class="p">)))</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">offset</span><span class="p">)))</span>
                <span class="n">spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">spks</span> <span class="o">&gt;=</span> <span class="n">onset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spks</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))])</span>

        <span class="k">for</span> <span class="n">context1</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">add_premotor_spk</span><span class="p">:</span>
                <span class="n">spk_list_context</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_ts</span> <span class="k">for</span> <span class="n">spk_ts</span><span class="p">,</span> <span class="n">context2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spk_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context2</span> <span class="o">==</span> <span class="n">context1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spk_list_context</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_ts</span> <span class="k">for</span> <span class="n">spk_ts</span><span class="p">,</span> <span class="n">context2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span>
                                    <span class="n">context2</span> <span class="o">==</span> <span class="n">context1</span><span class="p">]</span>
            <span class="n">isi_dict</span><span class="p">[</span><span class="n">context1</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_isi</span><span class="p">(</span><span class="n">spk_list_context</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">isi_dict</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nb_files</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of files per context</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nb_files : dict</span>
<span class="sd">            Number of files per context (&#39;U&#39;, &#39;D&#39;, &#39;All&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_files</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">nb_files</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">context</span> <span class="k">for</span> <span class="n">context</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span> <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">])</span>
        <span class="n">nb_files</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">context</span> <span class="k">for</span> <span class="n">context</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span> <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
        <span class="n">nb_files</span><span class="p">[</span><span class="s1">&#39;All&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_files</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">nb_files</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">nb_files</span>

<div class="viewcode-block" id="ClusterInfo.nb_bouts"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo.nb_bouts">[docs]</a>    <span class="k">def</span> <span class="nf">nb_bouts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">song_note</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of bouts per context</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        song_note : str</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nb_bouts : dict</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">..analysis.functions</span> <span class="kn">import</span> <span class="n">get_nb_bouts</span>

        <span class="n">nb_bouts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">syllable_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">syllable</span> <span class="k">for</span> <span class="n">syllable</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">syllables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">]</span>
        <span class="n">syllables</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">syllable_list</span><span class="p">)</span>
        <span class="n">nb_bouts</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_nb_bouts</span><span class="p">(</span><span class="n">song_note</span><span class="p">,</span> <span class="n">syllables</span><span class="p">)</span>

        <span class="n">syllable_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">syllable</span> <span class="k">for</span> <span class="n">syllable</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">syllables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span><span class="p">]</span>
        <span class="n">syllables</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">syllable_list</span><span class="p">)</span>
        <span class="n">nb_bouts</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_nb_bouts</span><span class="p">(</span><span class="n">song_note</span><span class="p">,</span> <span class="n">syllables</span><span class="p">)</span>
        <span class="n">nb_bouts</span><span class="p">[</span><span class="s1">&#39;All&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_bouts</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">nb_bouts</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">nb_bouts</span></div>

<div class="viewcode-block" id="ClusterInfo.nb_motifs"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo.nb_motifs">[docs]</a>    <span class="k">def</span> <span class="nf">nb_motifs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">motif</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of motifs per context</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        motf : str</span>
<span class="sd">            Define song motif (e.g., &#39;abcd&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nb_motifs : dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.functions</span> <span class="kn">import</span> <span class="n">find_str</span>

        <span class="n">nb_motifs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">syllable_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">syllable</span> <span class="k">for</span> <span class="n">syllable</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">syllables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">]</span>
        <span class="n">syllables</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">syllable_list</span><span class="p">)</span>
        <span class="n">nb_motifs</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">find_str</span><span class="p">(</span><span class="n">syllables</span><span class="p">,</span> <span class="n">motif</span><span class="p">))</span>

        <span class="n">syllable_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">syllable</span> <span class="k">for</span> <span class="n">syllable</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">syllables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s1">&#39;D&#39;</span><span class="p">]</span>
        <span class="n">syllables</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">syllable_list</span><span class="p">)</span>
        <span class="n">nb_motifs</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">find_str</span><span class="p">(</span><span class="n">syllables</span><span class="p">,</span> <span class="n">motif</span><span class="p">))</span>
        <span class="n">nb_motifs</span><span class="p">[</span><span class="s1">&#39;All&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nb_motifs</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">nb_motifs</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">nb_motifs</span></div>

<div class="viewcode-block" id="ClusterInfo.get_note_info"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ClusterInfo.get_note_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_note_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">note</span><span class="p">,</span>
                      <span class="n">pre_buffer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">post_buffer</span><span class="o">=</span><span class="mi">0</span>
                      <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain a class object (NoteInfo) for individual note</span>
<span class="sd">        spikes will be collected from note onset (+- pre_buffer) to offset (+- post_buffer)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        note : str</span>
<span class="sd">        pre_buffer : int</span>
<span class="sd">            amount of time buffer relative to the event onset (e.g., syllable onset)</span>
<span class="sd">        post_buffer : int</span>
<span class="sd">            amount of time buffer relative to the event offset (e.g., syllable onset)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NoteInfo : class object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">find_str</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="n">syllables</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">syllables</span><span class="p">)</span>
        <span class="n">onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">)</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">)</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">durations</span><span class="p">)</span>
        <span class="n">contexts</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)):</span>  <span class="c1"># concatenate contexts</span>
            <span class="n">contexts</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">syllables</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">find_str</span><span class="p">(</span><span class="n">syllables</span><span class="p">,</span> <span class="n">note</span><span class="p">))</span>  <span class="c1"># note indices</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ind</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>  <span class="c1"># note does not exist</span>
            <span class="k">return</span>
        <span class="n">note_onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">onsets</span><span class="p">[</span><span class="n">ind</span><span class="p">])))</span>
        <span class="n">note_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">offsets</span><span class="p">[</span><span class="n">ind</span><span class="p">])))</span>
        <span class="n">note_durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">durations</span><span class="p">[</span><span class="n">ind</span><span class="p">])))</span>
        <span class="n">note_contexts</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">contexts</span><span class="p">))[</span><span class="n">ind</span><span class="p">])</span>

        <span class="c1"># Get spike info</span>
        <span class="n">spk_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span>
        <span class="n">note_spk_ts_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">onset</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">note_onsets</span><span class="p">,</span> <span class="n">note_offsets</span><span class="p">):</span>
            <span class="n">note_spk_ts_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">spk_ts</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">spk_ts</span> <span class="o">&gt;=</span> <span class="n">onset</span> <span class="o">-</span> <span class="n">pre_buffer</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spk_ts</span> <span class="o">&lt;=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">post_buffer</span><span class="p">))])</span>

        <span class="c1"># Organize data into a dictionary</span>
        <span class="n">note_info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;note&#39;</span><span class="p">:</span> <span class="n">note</span><span class="p">,</span>
            <span class="s1">&#39;onsets&#39;</span><span class="p">:</span> <span class="n">note_onsets</span><span class="p">,</span>
            <span class="s1">&#39;offsets&#39;</span><span class="p">:</span> <span class="n">note_offsets</span><span class="p">,</span>
            <span class="s1">&#39;durations&#39;</span><span class="p">:</span> <span class="n">note_durations</span><span class="p">,</span>
            <span class="s1">&#39;contexts&#39;</span><span class="p">:</span> <span class="n">note_contexts</span><span class="p">,</span>
            <span class="s1">&#39;median_dur&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">note_durations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="s1">&#39;spk_ts&#39;</span><span class="p">:</span> <span class="n">note_spk_ts_list</span><span class="p">,</span>
            <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>  <span class="c1"># directory where the data exists</span>
            <span class="s1">&#39;pre_buffer&#39;</span> <span class="p">:</span> <span class="n">pre_buffer</span><span class="p">,</span>
            <span class="s1">&#39;post_buffer&#39;</span> <span class="p">:</span> <span class="n">post_buffer</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">NoteInfo</span><span class="p">(</span><span class="n">note_info</span><span class="p">)</span>  <span class="c1"># return note info</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">open_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Open the data folder&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">open_folder</span>

        <span class="n">open_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span></div>


<div class="viewcode-block" id="NoteInfo"><a class="viewcode-back" href="../../analysis.html#analysis.spike.NoteInfo">[docs]</a><span class="k">class</span> <span class="nc">NoteInfo</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing information about a single note syllable and its associated spikes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">note_dict</span><span class="p">):</span>

        <span class="c1"># Set the dictionary values to class attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">note_dict</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">note_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="c1"># Perform PLW (piecewise linear warping)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_warp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">piecewise_linear_warping</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

<div class="viewcode-block" id="NoteInfo.select_context"><a class="viewcode-back" href="../../analysis.html#analysis.spike.NoteInfo.select_context">[docs]</a>    <span class="k">def</span> <span class="nf">select_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_context</span> <span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">keep_median_duration</span><span class="o">=</span><span class="kc">True</span>
                       <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select one context</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_context : str</span>
<span class="sd">            &#39;U&#39; or &#39;D&#39;</span>
<span class="sd">        keep_median_duration : bool</span>
<span class="sd">            Normally medial note duration is calculated using all syllables regardless of the context</span>
<span class="sd">            one may prefer to use this median to reduce variability when calculating pcc</span>
<span class="sd">            if set False, new median duration will be calculated using the selected notes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="n">zipped_list</span> <span class="o">=</span> \
            <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">durations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_warp</span><span class="p">))</span>
        <span class="n">zipped_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">target_context</span><span class="p">,</span> <span class="n">zipped_list</span><span class="p">))</span>  <span class="c1"># filter context</span>
        <span class="n">unzipped_object</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zipped_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">durations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_warp</span> <span class="o">=</span> \
            <span class="nb">list</span><span class="p">(</span><span class="n">unzipped_object</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">durations</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_warp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_warp</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_median_duration</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">median_dur</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">median_dur</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="NoteInfo.get_entropy"><a class="viewcode-back" href="../../analysis.html#analysis.spike.NoteInfo.get_entropy">[docs]</a>    <span class="k">def</span> <span class="nf">get_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;spectral&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate syllable entropy from all renditions and get the average</span>
<span class="sd">        Two versions : spectro-temporal entropy &amp; spectral entropy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">nb_note_crit</span>
        <span class="kn">from</span> <span class="nn">..analysis.functions</span> <span class="kn">import</span> <span class="n">get_spectral_entropy</span><span class="p">,</span> <span class="n">get_spectrogram</span><span class="p">,</span> <span class="n">find_str</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="n">entropy_mean</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">entropy_var</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">audio</span> <span class="o">=</span> <span class="n">AudioData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">context</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]:</span>

            <span class="n">se_mean_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">se_var_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">find_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nb_note_crit</span><span class="p">:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="n">ind</span><span class="p">]):</span>
                    <span class="n">timestamp</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">audio</span><span class="o">.</span><span class="n">extract</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span>  <span class="c1"># audio object</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">spect</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_spectrogram</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">audio</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
                    <span class="n">se</span> <span class="o">=</span> <span class="n">get_spectral_entropy</span><span class="p">(</span><span class="n">spect</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="n">se_mean_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">se_mean_arr</span><span class="p">,</span> <span class="n">se</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">])</span>  <span class="c1"># spectral entropy averaged over time bins per rendition</span>
                        <span class="n">se_var_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">se_var_arr</span><span class="p">,</span> <span class="n">se</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">])</span>  <span class="c1"># spectral entropy variance per rendition</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">se_mean_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">se_mean_arr</span><span class="p">,</span> <span class="n">se</span><span class="p">)</span>  <span class="c1"># spectral entropy time-resolved</span>
                <span class="n">entropy_mean</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">se_mean_arr</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">entropy_var</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">se_var_arr</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mi">5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;spectro_temporal&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">entropy_mean</span><span class="p">,</span> <span class="n">entropy_var</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># spectral entropy (does not have entropy variance)</span>
            <span class="k">return</span> <span class="n">entropy_mean</span></div>

<div class="viewcode-block" id="NoteInfo.piecewise_linear_warping"><a class="viewcode-back" href="../../analysis.html#analysis.spike.NoteInfo.piecewise_linear_warping">[docs]</a>    <span class="k">def</span> <span class="nf">piecewise_linear_warping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform piecewise linear warping per note&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="n">note_spk_ts_warp_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">onset</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">spk_ts</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">durations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">):</span>
            <span class="n">spk_ts_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">spk_ts</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">median_dur</span> <span class="o">/</span> <span class="n">duration</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">spk_ts_temp</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">spk_ts</span><span class="p">[</span><span class="n">spk_ts</span> <span class="o">&gt;=</span> <span class="n">onset</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spk_ts</span> <span class="o">&gt;=</span> <span class="n">onset</span><span class="p">)</span>

            <span class="n">spk_ts_temp</span> <span class="o">=</span> <span class="p">((</span><span class="n">ratio</span> <span class="o">*</span> <span class="p">((</span><span class="n">spk_ts_temp</span> <span class="o">-</span> <span class="n">onset</span><span class="p">)))</span> <span class="o">+</span> <span class="n">origin</span><span class="p">)</span> <span class="o">+</span> <span class="n">onset</span>
            <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">spk_ts_new</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">spk_ts_temp</span><span class="p">)</span>  <span class="c1"># replace original spk timestamps with warped timestamps</span>
            <span class="n">note_spk_ts_warp_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_ts_new</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">note_spk_ts_warp_list</span></div>

<div class="viewcode-block" id="NoteInfo.get_note_peth"><a class="viewcode-back" href="../../analysis.html#analysis.spike.NoteInfo.get_note_peth">[docs]</a>    <span class="k">def</span> <span class="nf">get_note_peth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_warp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pre_evt_buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">bin_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">nb_bins</span><span class="o">=</span><span class="kc">None</span>
                      <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get peri-event time histograms for single syllable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_warp : perform piecewise linear transform</span>
<span class="sd">        shuffle : add jitter to spike timestamps</span>
<span class="sd">        duration : duration of the peth</span>
<span class="sd">        bin_size : size of single bin (in ms) (take values from peth_parm by default)</span>
<span class="sd">        nb_bins : number of time bins (take values from peth_parm by default)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PethInfo : class object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">peth_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
            <span class="n">peth</span><span class="p">,</span> <span class="n">time_bin</span><span class="p">,</span> <span class="n">peth_parm</span> <span class="o">=</span> \
                <span class="n">get_peth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_jittered</span><span class="p">,</span>
                         <span class="n">pre_evt_buffer</span><span class="o">=</span><span class="n">pre_evt_buffer</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span>
                         <span class="n">bin_size</span><span class="o">=</span><span class="n">bin_size</span><span class="p">,</span>
                         <span class="n">nb_bins</span><span class="o">=</span><span class="n">nb_bins</span>
                         <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">time_warp</span><span class="p">:</span>  <span class="c1"># peth calculated from time-warped spikes by default</span>
                <span class="c1"># peth, time_bin = get_note_peth(self.onsets, self.spk_ts_warp, self.median_durations.sum())  # truncated version to fit the motif duration</span>
                <span class="n">peth</span><span class="p">,</span> <span class="n">time_bin</span><span class="p">,</span> <span class="n">peth_parm</span> <span class="o">=</span> \
                    <span class="n">get_peth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_warp</span><span class="p">,</span>
                             <span class="n">pre_evt_buffer</span><span class="o">=</span><span class="n">pre_evt_buffer</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span>
                             <span class="n">bin_size</span> <span class="o">=</span> <span class="n">bin_size</span><span class="p">,</span>
                             <span class="n">nb_bins</span> <span class="o">=</span> <span class="n">nb_bins</span>
                             <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">peth</span><span class="p">,</span> <span class="n">time_bin</span><span class="p">,</span> <span class="n">peth_parm</span> <span class="o">=</span> \
                    <span class="n">get_peth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">,</span>
                             <span class="n">pre_evt_buffer</span><span class="o">=</span><span class="n">pre_evt_buffer</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span>
                             <span class="n">bin_size</span><span class="o">=</span><span class="n">bin_size</span><span class="p">,</span>
                             <span class="n">nb_bins</span><span class="o">=</span><span class="n">nb_bins</span>
                             <span class="p">)</span>

        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;peth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peth</span>
        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;time_bin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_bin</span>
        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peth_parm</span>
        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;contexts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span>
        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;median_duration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">median_dur</span>
        <span class="k">return</span> <span class="n">PethInfo</span><span class="p">(</span><span class="n">peth_dict</span><span class="p">)</span>  <span class="c1"># return peth class object for further analysis</span></div>

<div class="viewcode-block" id="NoteInfo.jitter_spk_ts"><a class="viewcode-back" href="../../analysis.html#analysis.spike.NoteInfo.jitter_spk_ts">[docs]</a>    <span class="k">def</span> <span class="nf">jitter_spk_ts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shuffle_limit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a random temporal jitter to the spike</span>
<span class="sd">        This version limit the jittered timestamp within the motif window</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">pre_motor_win_size</span>

        <span class="n">spk_ts_jittered_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="p">(</span><span class="n">onset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">spk_ts</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_zip</span><span class="p">):</span>

            <span class="c1"># Find motif onset &amp; offset</span>
            <span class="n">onset</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">onset</span><span class="p">)</span> <span class="o">-</span> <span class="n">pre_motor_win_size</span>  <span class="c1"># start from the premotor window</span>

            <span class="n">jittered_spk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">spk_ind</span><span class="p">,</span> <span class="n">spk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spk_ts</span><span class="p">):</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">shuffle_limit</span><span class="p">,</span> <span class="n">shuffle_limit</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">new_spk</span> <span class="o">=</span> <span class="n">spk</span> <span class="o">+</span> <span class="n">jitter</span>
                    <span class="k">if</span> <span class="n">onset</span> <span class="o">&lt;</span> <span class="n">new_spk</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">:</span>
                        <span class="n">jittered_spk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jittered_spk</span><span class="p">,</span> <span class="n">spk</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">)</span>
                        <span class="k">break</span>

            <span class="n">spk_ts_jittered_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jittered_spk</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_jittered</span> <span class="o">=</span> <span class="n">spk_ts_jittered_list</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nb_note</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns number of notes per context&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">find_str</span>

        <span class="n">nb_note</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">context</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]:</span>
            <span class="n">nb_note</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">find_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">,</span> <span class="n">context</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nb_note</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mean_fr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns mean firing rates for the note (includes pre-motor window) per context&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">nb_note_crit</span><span class="p">,</span> <span class="n">pre_motor_win_size</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">find_str</span>

        <span class="n">note_spk</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">note_fr</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">context1</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_note</span><span class="p">[</span><span class="n">context1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nb_note_crit</span><span class="p">:</span>
                <span class="n">note_spk</span><span class="p">[</span><span class="n">context1</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">spk</span><span class="p">)</span> <span class="k">for</span> <span class="n">context2</span><span class="p">,</span> <span class="n">spk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context2</span> <span class="o">==</span> <span class="n">context1</span><span class="p">])</span>
                <span class="n">note_fr</span><span class="p">[</span><span class="n">context1</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="nb">round</span><span class="p">(</span><span class="n">note_spk</span><span class="p">[</span><span class="n">context1</span><span class="p">]</span> <span class="o">/</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">durations</span><span class="p">[</span><span class="n">find_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">,</span> <span class="n">context1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">pre_motor_win_size</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1E3</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">note_fr</span><span class="p">[</span><span class="n">context1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">note_fr</span></div>


<div class="viewcode-block" id="MotifInfo"><a class="viewcode-back" href="../../analysis.html#analysis.spike.MotifInfo">[docs]</a><span class="k">class</span> <span class="nc">MotifInfo</span><span class="p">(</span><span class="n">ClusterInfo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class object for motif information</span>
<span class="sd">    child class of ClusterInfo</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel_nb</span><span class="p">,</span> <span class="n">unit_nb</span><span class="p">,</span> <span class="n">motif</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;rhd&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">channel_nb</span><span class="p">,</span> <span class="n">unit_nb</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">motif</span> <span class="o">=</span> <span class="n">motif</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># Load motif info</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">/</span> <span class="s2">&quot;MotifInfo_</span><span class="si">{}</span><span class="s2">_Cluster</span><span class="si">{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_nb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">file_name</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>  <span class="c1"># if .npy doesn&#39;t exist or want to update the file</span>
            <span class="n">motif_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_motif</span><span class="p">()</span>
            <span class="c1"># Save info dict as a numpy object</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">motif_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">motif_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="c1"># Set the dictionary values to class attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">motif_info</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">motif_info</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;spk_wf&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete_wf</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_delete_wf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete waveform attribute (not needed for this)&quot;&quot;&quot;</span>
        <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;spk_wf&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_motif</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load motif info&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">peth_parm</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">find_str</span>

        <span class="c1"># Store values here</span>
        <span class="n">file_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spk_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">onset_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">offset_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">syllable_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">duration_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">context_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">list_zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">syllables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">file</span><span class="p">,</span> <span class="n">spks</span><span class="p">,</span> <span class="n">onsets</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">syllables</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">list_zip</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading... &#39;</span> <span class="o">+</span> <span class="n">file</span><span class="p">)</span>
            <span class="n">onsets</span> <span class="o">=</span> <span class="n">onsets</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Find motifs</span>
            <span class="n">motif_ind</span> <span class="o">=</span> <span class="n">find_str</span><span class="p">(</span><span class="n">syllables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">motif</span><span class="p">)</span>

            <span class="c1"># Get syllable, analysis time stamps</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">motif_ind</span><span class="p">:</span>
                <span class="c1"># start (first syllable) and stop (last syllable) index of a motif</span>
                <span class="n">start_ind</span> <span class="o">=</span> <span class="n">ind</span>
                <span class="n">stop_ind</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">motif</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="n">motif_onset</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">onsets</span><span class="p">[</span><span class="n">start_ind</span><span class="p">])</span>
                <span class="n">motif_offset</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="n">stop_ind</span><span class="p">])</span>
                <span class="c1"># Includes pre-motor spikes</span>
                <span class="n">motif_spk</span> <span class="o">=</span> <span class="n">spks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">spks</span> <span class="o">&gt;=</span> <span class="n">motif_onset</span> <span class="o">-</span> <span class="n">peth_parm</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spks</span> <span class="o">&lt;=</span> <span class="n">motif_offset</span><span class="p">))]</span>
                <span class="n">onsets_in_motif</span> <span class="o">=</span> <span class="n">onsets</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">stop_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># list of motif onset timestamps</span>
                <span class="n">offsets_in_motif</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">stop_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># list of motif offset timestamps</span>

                <span class="n">file_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
                <span class="n">spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">motif_spk</span><span class="p">)</span>
                <span class="n">duration_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">motif_offset</span> <span class="o">-</span> <span class="n">motif_onset</span><span class="p">)</span>
                <span class="n">onset_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onsets_in_motif</span><span class="p">)</span>
                <span class="n">offset_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offsets_in_motif</span><span class="p">)</span>
                <span class="n">syllable_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">syllables</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">stop_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">context_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="c1"># Organize event-related info into a single dictionary object</span>
        <span class="n">motif_info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;files&#39;</span><span class="p">:</span> <span class="n">file_list</span><span class="p">,</span>
            <span class="s1">&#39;spk_ts&#39;</span><span class="p">:</span> <span class="n">spk_list</span><span class="p">,</span>
            <span class="s1">&#39;onsets&#39;</span><span class="p">:</span> <span class="n">onset_list</span><span class="p">,</span>
            <span class="s1">&#39;offsets&#39;</span><span class="p">:</span> <span class="n">offset_list</span><span class="p">,</span>
            <span class="s1">&#39;durations&#39;</span><span class="p">:</span> <span class="n">duration_list</span><span class="p">,</span>  <span class="c1"># this is motif durations</span>
            <span class="s1">&#39;syllables&#39;</span><span class="p">:</span> <span class="n">syllable_list</span><span class="p">,</span>
            <span class="s1">&#39;contexts&#39;</span><span class="p">:</span> <span class="n">context_list</span><span class="p">,</span>
            <span class="s1">&#39;parameter&#39;</span><span class="p">:</span> <span class="n">peth_parm</span>
        <span class="p">}</span>

        <span class="c1"># Set the dictionary values to class attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">motif_info</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">motif_info</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="c1"># Get duration</span>
        <span class="n">note_duration_list</span><span class="p">,</span> <span class="n">median_duration_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_note_duration</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">note_durations</span> <span class="o">=</span> <span class="n">note_duration_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">median_durations</span> <span class="o">=</span> <span class="n">median_duration_list</span>
        <span class="n">motif_info</span><span class="p">[</span><span class="s1">&#39;note_durations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">note_duration_list</span>
        <span class="n">motif_info</span><span class="p">[</span><span class="s1">&#39;median_durations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">median_duration_list</span>

        <span class="c1"># Get PLW (piecewise linear warping)</span>
        <span class="n">spk_ts_warp_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">piecewise_linear_warping</span><span class="p">()</span>
        <span class="c1"># self.spk_ts_warp = spk_ts_warp_list</span>
        <span class="n">motif_info</span><span class="p">[</span><span class="s1">&#39;spk_ts_warp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spk_ts_warp_list</span>

        <span class="k">return</span> <span class="n">motif_info</span>

    <span class="k">def</span> <span class="nf">_print_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Load motif </span><span class="si">{self.name}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># print attributes</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">open_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">open_folder</span>
        <span class="n">open_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

<div class="viewcode-block" id="MotifInfo.get_note_duration"><a class="viewcode-back" href="../../analysis.html#analysis.spike.MotifInfo.get_note_duration">[docs]</a>    <span class="k">def</span> <span class="nf">get_note_duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate note &amp; gap duration per motif</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">note_durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">motif</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">list_zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">motif_ind</span><span class="p">,</span> <span class="p">(</span><span class="n">onset</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_zip</span><span class="p">):</span>

            <span class="c1"># Convert from string to array of floats</span>
            <span class="n">onset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">onset</span><span class="p">)))</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">offset</span><span class="p">)))</span>

            <span class="c1"># Calculate note &amp; interval duration</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">onset</span><span class="p">,</span> <span class="n">offset</span><span class="p">]</span> <span class="k">for</span> <span class="n">onset</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">onset</span><span class="p">,</span> <span class="n">offset</span><span class="p">)]</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="p">[])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">note_durations</span><span class="p">[</span><span class="n">motif_ind</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Get median duration</span>
        <span class="n">median_durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">note_durations</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">note_durations</span><span class="p">,</span> <span class="n">median_durations</span></div>

<div class="viewcode-block" id="MotifInfo.piecewise_linear_warping"><a class="viewcode-back" href="../../analysis.html#analysis.spike.MotifInfo.piecewise_linear_warping">[docs]</a>    <span class="k">def</span> <span class="nf">piecewise_linear_warping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs piecewise linear warping on raw analysis timestamps</span>
<span class="sd">        Based on each median note and gap durations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">extract_ind</span>

        <span class="n">spk_ts_warped_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">note_durations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">motif_ind</span><span class="p">,</span> <span class="p">(</span><span class="n">durations</span><span class="p">,</span> <span class="n">onset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">spk_ts</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_zip</span><span class="p">):</span>  <span class="c1"># per motif</span>

            <span class="n">onset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">onset</span><span class="p">)))</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">offset</span><span class="p">)))</span>
            <span class="c1"># Make a deep copy of spk_ts so as to make it modification won&#39;t affect the original</span>
            <span class="n">spk_ts_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">spk_ts</span><span class="p">)</span>

            <span class="c1"># Calculate note &amp; interval duration</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">onset</span><span class="p">,</span> <span class="n">offset</span><span class="p">]</span> <span class="k">for</span> <span class="n">onset</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">onset</span><span class="p">,</span> <span class="n">offset</span><span class="p">)]</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="p">[])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">median_durations</span><span class="p">)):</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">median_durations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">durations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">origin</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">origin</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">median_durations</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Add spikes from motif</span>
                <span class="n">ind</span><span class="p">,</span> <span class="n">spk_ts_temp</span> <span class="o">=</span> <span class="n">extract_ind</span><span class="p">(</span><span class="n">spk_ts</span><span class="p">,</span> <span class="p">[</span><span class="n">timestamp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
                <span class="n">spk_ts_temp</span> <span class="o">=</span> <span class="p">((</span><span class="n">ratio</span> <span class="o">*</span> <span class="p">((</span><span class="n">spk_ts_temp</span> <span class="o">-</span> <span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">diff</span><span class="p">))</span> <span class="o">+</span> <span class="n">origin</span><span class="p">)</span> <span class="o">+</span> <span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># spk_ts_new = np.append(spk_ts_new, spk_ts_temp)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">spk_ts_new</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">spk_ts_temp</span><span class="p">)</span>  <span class="c1"># replace original spk timestamps with warped timestamps</span>

            <span class="n">spk_ts_warped_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_ts_new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spk_ts_warped_list</span></div>

<div class="viewcode-block" id="MotifInfo.get_mean_fr"><a class="viewcode-back" href="../../analysis.html#analysis.spike.MotifInfo.get_mean_fr">[docs]</a>    <span class="k">def</span> <span class="nf">get_mean_fr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_pre_motor</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate mean firing rates during motif</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        add_pre_motor : bool</span>
<span class="sd">            Set True if you want to include spikes from the pre-motor window for calculating firing rates</span>
<span class="sd">            (False by default)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">peth_parm</span>

        <span class="n">fr_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">motif_spk_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span>

        <span class="c1"># Make sure spikes from the pre-motif buffer is not included in calculation</span>
        <span class="k">for</span> <span class="n">onset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">spks</span> <span class="ow">in</span> <span class="n">list_zip</span><span class="p">:</span>

            <span class="n">onset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">onset</span><span class="p">)))</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">offset</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">add_pre_motor</span><span class="p">:</span>
                <span class="n">motif_spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">spks</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">onset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">peth_parm</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">]))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spks</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">motif_spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">spks</span> <span class="o">&gt;=</span> <span class="n">onset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spks</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))])</span>

        <span class="k">for</span> <span class="n">context1</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">):</span>
            <span class="n">nb_spk</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">spk</span><span class="p">)</span> <span class="k">for</span> <span class="n">spk</span><span class="p">,</span> <span class="n">context2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">motif_spk_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context2</span> <span class="o">==</span> <span class="n">context1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">add_pre_motor</span><span class="p">:</span>
                <span class="n">total_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">duration</span> <span class="o">+</span> <span class="n">peth_parm</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">duration</span><span class="p">,</span> <span class="n">context2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">durations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context2</span> <span class="o">==</span> <span class="n">context1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">total_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">duration</span> <span class="k">for</span> <span class="n">duration</span><span class="p">,</span> <span class="n">context2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">durations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span> <span class="n">context2</span> <span class="o">==</span> <span class="n">context1</span><span class="p">])</span>

            <span class="n">mean_fr</span> <span class="o">=</span> <span class="n">nb_spk</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_duration</span> <span class="o">/</span> <span class="mf">1E3</span><span class="p">)</span>
            <span class="n">fr_dict</span><span class="p">[</span><span class="n">context1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">mean_fr</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># print(&quot;mean_fr added&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_fr</span> <span class="o">=</span> <span class="n">fr_dict</span></div>

<div class="viewcode-block" id="MotifInfo.jitter_spk_ts"><a class="viewcode-back" href="../../analysis.html#analysis.spike.MotifInfo.jitter_spk_ts">[docs]</a>    <span class="k">def</span> <span class="nf">jitter_spk_ts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shuffle_limit</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a random temporal jitter to the spike</span>
<span class="sd">        This version limit the jittered timestamp within the motif window</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">pre_motor_win_size</span>

        <span class="n">spk_ts_jittered_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="p">(</span><span class="n">onset</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">spk_ts</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_zip</span><span class="p">):</span>

            <span class="c1"># Find motif onset &amp; offset</span>
            <span class="n">onset</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">onset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">pre_motor_win_size</span>  <span class="c1"># start from the premotor window</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">jittered_spk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">spk_ind</span><span class="p">,</span> <span class="n">spk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spk_ts</span><span class="p">):</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">jitter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">shuffle_limit</span><span class="p">,</span> <span class="n">shuffle_limit</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">new_spk</span> <span class="o">=</span> <span class="n">spk</span> <span class="o">+</span> <span class="n">jitter</span>
                    <span class="k">if</span> <span class="n">onset</span> <span class="o">&lt;</span> <span class="n">new_spk</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">:</span>
                        <span class="n">jittered_spk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jittered_spk</span><span class="p">,</span> <span class="n">spk</span> <span class="o">+</span> <span class="n">jitter</span><span class="p">)</span>
                        <span class="k">break</span>

            <span class="n">spk_ts_jittered_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jittered_spk</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_jittered</span> <span class="o">=</span> <span class="n">spk_ts_jittered_list</span></div>

<div class="viewcode-block" id="MotifInfo.get_peth"><a class="viewcode-back" href="../../analysis.html#analysis.spike.MotifInfo.get_peth">[docs]</a>    <span class="k">def</span> <span class="nf">get_peth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_warp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get peri-event time histogram &amp; raster during song motif</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_warp : bool</span>
<span class="sd">            perform piecewise linear transform</span>
<span class="sd">        shuffle : bool</span>
<span class="sd">            add jitter to spike timestamps</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PethInfo : class object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">peth_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>  <span class="c1"># Get peth with shuffled (jittered) spikes</span>
            <span class="n">peth</span><span class="p">,</span> <span class="n">time_bin</span><span class="p">,</span> <span class="n">peth_parm</span> <span class="o">=</span> <span class="n">get_peth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_jittered</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">time_warp</span><span class="p">:</span>  <span class="c1"># peth calculated from time-warped spikes by default</span>
                <span class="c1"># peth, time_bin = get_note_peth(self.onsets, self.spk_ts_warp, self.median_durations.sum())  # truncated version to fit the motif duration</span>
                <span class="n">peth</span><span class="p">,</span> <span class="n">time_bin</span><span class="p">,</span> <span class="n">peth_parm</span> <span class="o">=</span> <span class="n">get_peth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_warp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">peth</span><span class="p">,</span> <span class="n">time_bin</span><span class="p">,</span> <span class="n">peth_parm</span> <span class="o">=</span> <span class="n">get_peth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span>

        <span class="n">peth_parm</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;time_bin&#39;</span><span class="p">);</span> <span class="n">peth_parm</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nb_bins&#39;</span><span class="p">)</span>
        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;peth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peth</span>
        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;time_bin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_bin</span>
        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peth_parm</span>
        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;contexts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span>
        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;median_duration&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">median_durations</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">PethInfo</span><span class="p">(</span><span class="n">peth_dict</span><span class="p">)</span>  <span class="c1"># return peth class object for further analysis</span></div></div>


<div class="viewcode-block" id="PethInfo"><a class="viewcode-back" href="../../analysis.html#analysis.spike.PethInfo">[docs]</a><span class="k">class</span> <span class="nc">PethInfo</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peth_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class object for peri-event time histogram (PETH)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        peth_dict : dict</span>
<span class="sd">            &quot;peth&quot; : array  (nb of trials (motifs) x time bins), numbers indicate analysis counts in that bin</span>
<span class="sd">            &quot;contexts&quot; : list of strings, social contexts</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set the dictionary values to class attributes</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">peth_dict</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">peth_dict</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="c1"># Get conditional peth, fr, spike counts</span>
        <span class="n">peth_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">peth_dict</span><span class="p">[</span><span class="s1">&#39;All&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peth</span>
        <span class="k">for</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="o">==</span> <span class="n">context</span>
            <span class="n">peth_dict</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peth</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peth</span> <span class="o">=</span> <span class="n">peth_dict</span>

<div class="viewcode-block" id="PethInfo.get_fr"><a class="viewcode-back" href="../../analysis.html#analysis.spike.PethInfo.get_fr">[docs]</a>    <span class="k">def</span> <span class="nf">get_fr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gaussian_std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get trials-by-trial firing rates by default</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gaussian_std : int</span>
<span class="sd">            gaussian smoothing parameter. If not specified, read from analysis.parameters</span>
<span class="sd">        smoothing : bool</span>
<span class="sd">            performs gaussian smoothing on the firing rates</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if duration:</span>
        <span class="c1">#     ind = (((0 - peth_parm[&#39;buffer&#39;]) &lt;= time_bin) &amp; (time_bin &lt;= duration))</span>
        <span class="c1">#     peth = peth[:, ind]</span>
        <span class="c1">#     time_bin = time_bin[ind]</span>

        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">peth_parm</span><span class="p">,</span> <span class="n">gauss_std</span><span class="p">,</span> <span class="n">nb_note_crit</span>
        <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter1d</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">gaussian_std</span><span class="p">:</span>  <span class="c1"># if not specified, get the value fromm analysis.parameters</span>
            <span class="n">gaussian_std</span> <span class="o">=</span> <span class="n">gauss_std</span>

        <span class="c1"># Get trial-by-trial firing rates</span>
        <span class="n">fr_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peth</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># loop through different conditions in peth dict</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nb_note_crit</span><span class="p">:</span>
                <span class="n">fr</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="n">peth_parm</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1E3</span><span class="p">)</span>  <span class="c1"># in Hz</span>

                <span class="k">if</span> <span class="n">smoothing</span><span class="p">:</span>  <span class="c1"># Gaussian smoothing</span>
                    <span class="n">fr</span> <span class="o">=</span> <span class="n">gaussian_filter1d</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="n">gaussian_std</span><span class="p">)</span>

                <span class="c1"># Truncate values outside the range</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="p">(((</span><span class="mi">0</span> <span class="o">-</span> <span class="n">peth_parm</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">median_duration</span><span class="p">))</span>
                <span class="n">fr</span> <span class="o">=</span> <span class="n">fr</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>
                <span class="n">fr_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">fr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fr</span> <span class="o">=</span> <span class="n">fr_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

        <span class="c1"># Get mean firing rates</span>
        <span class="n">mean_fr_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">context</span><span class="p">,</span> <span class="n">fr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">fr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">mean_fr_dict</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="n">fr</span>
        <span class="k">if</span> <span class="n">smoothing</span><span class="p">:</span>
            <span class="n">mean_fr_dict</span><span class="p">[</span><span class="s1">&#39;gauss_std&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gauss_std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_fr</span> <span class="o">=</span> <span class="n">mean_fr_dict</span></div>

<div class="viewcode-block" id="PethInfo.get_pcc"><a class="viewcode-back" href="../../analysis.html#analysis.spike.PethInfo.get_pcc">[docs]</a>    <span class="k">def</span> <span class="nf">get_pcc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get pairwise cross-correlation&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">nb_note_crit</span>

        <span class="n">pcc_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># loop through different conditions in peth dict</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;All&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nb_note_crit</span><span class="p">:</span>
                    <span class="n">pcc</span> <span class="o">=</span> <span class="n">get_pcc</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">pcc_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcc</span> <span class="o">=</span> <span class="n">pcc_dict</span></div>

<div class="viewcode-block" id="PethInfo.get_fr_cv"><a class="viewcode-back" href="../../analysis.html#analysis.spike.PethInfo.get_fr_cv">[docs]</a>    <span class="k">def</span> <span class="nf">get_fr_cv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get coefficient of variation (CV) of firing rates&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_fr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_fr</span><span class="p">()</span>

        <span class="n">fr_cv</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">context</span><span class="p">,</span> <span class="n">fr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_fr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># loop through different conditions in peth dict</span>
            <span class="k">if</span> <span class="n">context</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]:</span>
                <span class="n">fr_cv</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">fr</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">fr</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fr_cv</span></div>

<div class="viewcode-block" id="PethInfo.get_sparseness"><a class="viewcode-back" href="../../analysis.html#analysis.spike.PethInfo.get_sparseness">[docs]</a>    <span class="k">def</span> <span class="nf">get_sparseness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get sparseness index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bin_size : int</span>
<span class="sd">            By default, it uses the same time bin size used in peth calculation (in ms)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sparseness : dict</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">gauss_std</span><span class="p">,</span> <span class="n">nb_note_crit</span>
        <span class="kn">import</span> <span class="nn">math</span>

        <span class="n">mean_fr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">sparseness</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">bin_size</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bin_size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">context</span><span class="p">,</span> <span class="n">peth</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peth</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">context</span> <span class="o">==</span> <span class="s1">&#39;All&#39;</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">new_peth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">peth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">nb_bins</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">peth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">bin_size</span><span class="p">)</span>
                <span class="n">bin_ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">start_ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">end_ind</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">bin_size</span>

                <span class="k">while</span> <span class="n">bin_ind</span> <span class="o">&lt;</span> <span class="n">nb_bins</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">end_ind</span> <span class="o">&gt;</span> <span class="n">peth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">end_ind</span> <span class="o">=</span> <span class="n">peth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># print(start_ind, end_ind)</span>
                    <span class="n">peth_bin</span> <span class="o">=</span> <span class="n">peth</span><span class="p">[:,</span> <span class="n">start_ind</span><span class="p">:</span> <span class="n">end_ind</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">peth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">new_peth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_peth</span><span class="p">,</span> <span class="n">peth_bin</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">start_ind</span> <span class="o">+=</span> <span class="n">bin_size</span>
                    <span class="n">end_ind</span> <span class="o">+=</span> <span class="n">bin_size</span>
                    <span class="n">bin_ind</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">fr</span> <span class="o">=</span> <span class="n">new_peth</span> <span class="o">/</span> <span class="p">(</span><span class="n">bin_size</span> <span class="o">/</span> <span class="mf">1E3</span><span class="p">)</span>  <span class="c1"># in Hz</span>
                <span class="n">mean_fr</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean_fr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_fr</span>

        <span class="c1"># Calculate sparseness</span>
        <span class="k">for</span> <span class="n">context</span><span class="p">,</span> <span class="n">fr</span> <span class="ow">in</span> <span class="n">mean_fr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">context</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]:</span> <span class="k">continue</span>
            <span class="n">norm_fr</span> <span class="o">=</span> <span class="n">fr</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>
            <span class="n">sparseness</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">norm_fr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">norm_fr</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">norm_fr</span><span class="p">))),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sparseness</span></div>

<div class="viewcode-block" id="PethInfo.get_spk_count"><a class="viewcode-back" href="../../analysis.html#analysis.spike.PethInfo.get_spk_count">[docs]</a>    <span class="k">def</span> <span class="nf">get_spk_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the number of spikes within a specified time window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">peth_parm</span><span class="p">,</span> <span class="n">spk_count_parm</span>

        <span class="n">win_size</span> <span class="o">=</span> <span class="n">spk_count_parm</span><span class="p">[</span><span class="s1">&#39;win_size&#39;</span><span class="p">]</span>
        <span class="n">spk_count_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">fano_factor_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">spk_count_cv_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">peth</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># loop through different conditions in peth dict</span>
            <span class="n">spk_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># (renditions x time bins)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;All&#39;</span><span class="p">:</span>  <span class="c1"># skip all trials</span>
                <span class="n">win_inc</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">win_size</span><span class="p">):</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span> <span class="n">win_size</span> <span class="o">+</span> <span class="n">win_inc</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># print(f&quot;from {i} to {win_size + win_inc}, count = {count}&quot;)</span>
                    <span class="n">spk_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spk_arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">count</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">win_inc</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Truncate values outside the range</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="p">(((</span><span class="mi">0</span> <span class="o">-</span> <span class="n">peth_parm</span><span class="p">[</span><span class="s1">&#39;buffer&#39;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">median_duration</span><span class="p">))</span>
                <span class="n">spk_arr</span> <span class="o">=</span> <span class="n">spk_arr</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ind</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                <span class="n">spk_count</span> <span class="o">=</span> <span class="n">spk_arr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">fano_factor</span> <span class="o">=</span> <span class="n">spk_arr</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">spk_arr</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># per time window (across renditions) (renditions x time window)</span>
                <span class="n">spk_count_cv</span> <span class="o">=</span> <span class="n">spk_count</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">spk_count</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># cv across time (single value)</span>

                <span class="c1"># store values in a dictionary</span>
                <span class="n">spk_count_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">spk_count</span>
                <span class="n">fano_factor_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">fano_factor</span>
                <span class="n">spk_count_cv_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">spk_count_cv</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spk_count</span> <span class="o">=</span> <span class="n">spk_count_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fano_factor</span> <span class="o">=</span> <span class="n">fano_factor_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spk_count_cv</span> <span class="o">=</span> <span class="n">spk_count_cv_dict</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># print attributes</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span></div>


<div class="viewcode-block" id="BoutInfo"><a class="viewcode-back" href="../../analysis.html#analysis.spike.BoutInfo">[docs]</a><span class="k">class</span> <span class="nc">BoutInfo</span><span class="p">(</span><span class="n">ClusterInfo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get song &amp; spike information for a song bout</span>
<span class="sd">    Child class of ClusterInfo</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel_nb</span><span class="p">,</span> <span class="n">unit_nb</span><span class="p">,</span> <span class="n">song_note</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;rhd&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">channel_nb</span><span class="p">,</span> <span class="n">unit_nb</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">song_note</span> <span class="o">=</span> <span class="n">song_note</span>

        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># Load bout info</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">/</span> <span class="s2">&quot;BoutInfo_</span><span class="si">{}</span><span class="s2">_Cluster</span><span class="si">{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_nb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">file_name</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>  <span class="c1"># if .npy doesn&#39;t exist or want to update the file</span>
            <span class="n">bout_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_bouts</span><span class="p">()</span>
            <span class="c1"># Save info dict as a numpy object</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">bout_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bout_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="c1"># Set the dictionary values to class attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">bout_info</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">bout_info</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_print_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Load bout </span><span class="si">{self.name}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">)</span>

<div class="viewcode-block" id="BoutInfo.load_bouts"><a class="viewcode-back" href="../../analysis.html#analysis.spike.BoutInfo.load_bouts">[docs]</a>    <span class="k">def</span> <span class="nf">load_bouts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Store values here</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">find_str</span>

        <span class="n">file_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spk_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">onset_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">offset_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">syllable_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">duration_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">context_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">list_zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">syllables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">file</span><span class="p">,</span> <span class="n">spks</span><span class="p">,</span> <span class="n">onsets</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">syllables</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">list_zip</span><span class="p">:</span>

            <span class="n">bout_ind</span> <span class="o">=</span> <span class="n">find_str</span><span class="p">(</span><span class="n">syllables</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bout_ind</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">start_ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start_ind</span> <span class="o">=</span> <span class="n">bout_ind</span><span class="p">[</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">stop_ind</span> <span class="o">=</span> <span class="n">bout_ind</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="c1"># breakpoint()</span>
                <span class="n">bout_onset</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">onsets</span><span class="p">[</span><span class="n">start_ind</span><span class="p">])</span>
                <span class="n">bout_offset</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="n">stop_ind</span><span class="p">])</span>

                <span class="n">bout_spk</span> <span class="o">=</span> <span class="n">spks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">spks</span> <span class="o">&gt;=</span> <span class="n">bout_onset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spks</span> <span class="o">&lt;=</span> <span class="n">bout_offset</span><span class="p">))]</span>
                <span class="n">onsets_in_bout</span> <span class="o">=</span> <span class="n">onsets</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">stop_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># list of bout onset timestamps</span>
                <span class="n">offsets_in_bout</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">stop_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># list of bout offset timestamps</span>

                <span class="n">file_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
                <span class="n">spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bout_spk</span><span class="p">)</span>
                <span class="n">duration_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bout_offset</span> <span class="o">-</span> <span class="n">bout_onset</span><span class="p">)</span>
                <span class="n">onset_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">onsets_in_bout</span><span class="p">)</span>
                <span class="n">offset_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offsets_in_bout</span><span class="p">)</span>
                <span class="n">syllable_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">syllables</span><span class="p">[</span><span class="n">start_ind</span><span class="p">:</span><span class="n">stop_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">context_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="c1"># Organize event-related info into a single dictionary object</span>
        <span class="n">bout_info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;files&#39;</span><span class="p">:</span> <span class="n">file_list</span><span class="p">,</span>
            <span class="s1">&#39;spk_ts&#39;</span><span class="p">:</span> <span class="n">spk_list</span><span class="p">,</span>
            <span class="s1">&#39;onsets&#39;</span><span class="p">:</span> <span class="n">onset_list</span><span class="p">,</span>
            <span class="s1">&#39;offsets&#39;</span><span class="p">:</span> <span class="n">offset_list</span><span class="p">,</span>
            <span class="s1">&#39;durations&#39;</span><span class="p">:</span> <span class="n">duration_list</span><span class="p">,</span>  <span class="c1"># this is bout durations</span>
            <span class="s1">&#39;syllables&#39;</span><span class="p">:</span> <span class="n">syllable_list</span><span class="p">,</span>
            <span class="s1">&#39;contexts&#39;</span><span class="p">:</span> <span class="n">context_list</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">bout_info</span></div></div>


<div class="viewcode-block" id="BaselineInfo"><a class="viewcode-back" href="../../analysis.html#analysis.spike.BaselineInfo">[docs]</a><span class="k">class</span> <span class="nc">BaselineInfo</span><span class="p">(</span><span class="n">ClusterInfo</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel_nb</span><span class="p">,</span> <span class="n">unit_nb</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;rhd&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">channel_nb</span><span class="p">,</span> <span class="n">unit_nb</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">baseline</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">find_str</span>

        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># Load baseline info</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">/</span> <span class="s2">&quot;BaselineInfo_</span><span class="si">{}</span><span class="s2">_Cluster</span><span class="si">{}</span><span class="s2">.npy&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unit_nb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">file_name</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>  <span class="c1"># if .npy doesn&#39;t exist or want to update the file</span>

            <span class="c1"># Store values in here</span>
            <span class="n">file_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">spk_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nb_spk_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">duration_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">context_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">baseline_info</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">list_zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">syllables</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">file</span><span class="p">,</span> <span class="n">spks</span><span class="p">,</span> <span class="n">file_start</span><span class="p">,</span> <span class="n">onsets</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">syllables</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">list_zip</span><span class="p">:</span>

                <span class="n">bout_ind_list</span> <span class="o">=</span> <span class="n">find_str</span><span class="p">(</span><span class="n">syllables</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
                <span class="n">bout_ind_list</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># start from the first index</span>

                <span class="k">for</span> <span class="n">bout_ind</span> <span class="ow">in</span> <span class="n">bout_ind_list</span><span class="p">:</span>
                    <span class="c1"># print(bout_ind)</span>
                    <span class="k">if</span> <span class="n">bout_ind</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">syllables</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># skip if * indicates the end syllable</span>
                        <span class="k">continue</span>

                    <span class="n">baseline_onset</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">onsets</span><span class="p">[</span><span class="n">bout_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">[</span><span class="s1">&#39;time_buffer&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">[</span><span class="s1">&#39;time_win&#39;</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">bout_ind</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">baseline_onset</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">offsets</span><span class="p">[</span>
                                                                   <span class="n">bout_ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>  <span class="c1"># skip if the baseline starts before the offset of the previous syllable</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">baseline_onset</span> <span class="o">&lt;</span> <span class="n">file_start</span><span class="p">:</span>
                        <span class="n">baseline_onset</span> <span class="o">=</span> <span class="n">file_start</span>

                    <span class="n">baseline_offset</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">onsets</span><span class="p">[</span><span class="n">bout_ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">[</span><span class="s1">&#39;time_buffer&#39;</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">baseline_offset</span> <span class="o">-</span> <span class="n">baseline_onset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># skip if there&#39;s not enough baseline period at the start of a file</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">baseline_onset</span> <span class="o">&gt;</span> <span class="n">baseline_offset</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;start time =</span><span class="si">{}</span><span class="s1"> to end time = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">baseline_onset</span><span class="p">,</span> <span class="n">baseline_offset</span><span class="p">))</span>

                    <span class="n">baseline_spk</span> <span class="o">=</span> <span class="n">spks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">spks</span> <span class="o">&gt;=</span> <span class="n">baseline_onset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spks</span> <span class="o">&lt;=</span> <span class="n">baseline_offset</span><span class="p">))]</span>

                    <span class="n">file_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
                    <span class="n">spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">baseline_spk</span><span class="p">)</span>
                    <span class="n">nb_spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">baseline_spk</span><span class="p">))</span>
                    <span class="n">duration_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">baseline_offset</span> <span class="o">-</span> <span class="n">baseline_onset</span><span class="p">))</span>  <span class="c1"># convert to seconds for calculating in Hz</span>
                    <span class="n">context_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

            <span class="n">baseline_info</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;files&#39;</span><span class="p">:</span> <span class="n">file_list</span><span class="p">,</span>
                <span class="s1">&#39;spk_ts&#39;</span><span class="p">:</span> <span class="n">spk_list</span><span class="p">,</span>
                <span class="s1">&#39;nb_spk&#39;</span><span class="p">:</span> <span class="n">nb_spk_list</span><span class="p">,</span>
                <span class="s1">&#39;durations&#39;</span><span class="p">:</span> <span class="n">duration_list</span><span class="p">,</span>
                <span class="s1">&#39;contexts&#39;</span><span class="p">:</span> <span class="n">context_list</span><span class="p">,</span>
                <span class="s1">&#39;parameter&#39;</span><span class="p">:</span> <span class="n">baseline</span>
            <span class="p">}</span>
            <span class="c1"># Save baseline_info as a numpy object</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">baseline_info</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">baseline_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="c1"># Set the dictionary values to class attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">baseline_info</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">baseline_info</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_print_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Load baseline </span><span class="si">{self.name}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="BaselineInfo.get_correlogram"><a class="viewcode-back" href="../../analysis.html#analysis.spike.BaselineInfo.get_correlogram">[docs]</a>    <span class="k">def</span> <span class="nf">get_correlogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_spk_list</span><span class="p">,</span> <span class="n">target_spk_list</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override the parent method</span>
<span class="sd">        combine correlogram from undir and dir since no contextual differentiation is needed in baseline</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">spk_corr_parm</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="n">correlogram_all</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_correlogram</span><span class="p">(</span><span class="n">ref_spk_list</span><span class="p">,</span> <span class="n">target_spk_list</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">correlogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;time_bin&#39;</span><span class="p">]))</span>

        <span class="c1"># Combine correlogram from two contexts</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">correlogram_all</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]:</span>
                <span class="n">correlogram</span> <span class="o">+=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">correlogram</span>  <span class="c1"># return class object for further analysis</span></div>

<div class="viewcode-block" id="BaselineInfo.get_jittered_corr"><a class="viewcode-back" href="../../analysis.html#analysis.spike.BaselineInfo.get_jittered_corr">[docs]</a>    <span class="k">def</span> <span class="nf">get_jittered_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">corr_shuffle</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="n">correlogram_jitter</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">corr_shuffle</span><span class="p">[</span><span class="s1">&#39;shuffle_iter&#39;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jitter_spk_ts</span><span class="p">(</span><span class="n">corr_shuffle</span><span class="p">[</span><span class="s1">&#39;shuffle_limit&#39;</span><span class="p">])</span>
            <span class="n">corr_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_correlogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_jittered</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts_jittered</span><span class="p">)</span>
            <span class="n">correlogram_jitter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr_temp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">correlogram_jitter</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaselineInfo.get_isi"><a class="viewcode-back" href="../../analysis.html#analysis.spike.BaselineInfo.get_isi">[docs]</a>    <span class="k">def</span> <span class="nf">get_isi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get inter-spike interval&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_isi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mean_fr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mean firing rates&quot;&quot;&quot;</span>
        <span class="n">nb_spk</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">spk_ts</span><span class="p">)</span> <span class="k">for</span> <span class="n">spk_ts</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">])</span>
        <span class="n">total_duration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">durations</span><span class="p">)</span>
        <span class="n">mean_fr</span> <span class="o">=</span> <span class="n">nb_spk</span> <span class="o">/</span> <span class="p">(</span><span class="n">total_duration</span> <span class="o">/</span> <span class="mf">1E3</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">mean_fr</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># print attributes</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span></div>


<div class="viewcode-block" id="AudioData"><a class="viewcode-back" href="../../analysis.html#analysis.spike.AudioData">[docs]</a><span class="k">class</span> <span class="nc">AudioData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an object that has concatenated audio signal and its timestamps</span>
<span class="sd">    Get all data by default; specify time range if needed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;.wav&#39;</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..analysis.load</span> <span class="kn">import</span> <span class="n">load_audio</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="nb">format</span>

        <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">/</span> <span class="s2">&quot;AudioData.npy&quot;</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">file_name</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>  <span class="c1"># if .npy doesn&#39;t exist or want to update the file</span>
            <span class="n">audio_info</span> <span class="o">=</span> <span class="n">load_audio</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">audio_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="c1"># Set the dictionary values to class attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">audio_info</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">audio_info</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># print attributes</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">open_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">open_folder</span>
        <span class="n">open_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

<div class="viewcode-block" id="AudioData.extract"><a class="viewcode-back" href="../../analysis.html#analysis.spike.AudioData.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_range</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts data from the specified range</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_range : list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span></div>

<div class="viewcode-block" id="AudioData.spectrogram"><a class="viewcode-back" href="../../analysis.html#analysis.spike.AudioData.spectrogram">[docs]</a>    <span class="k">def</span> <span class="nf">spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">freq_range</span><span class="o">=</span><span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">8000</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Calculate spectrogram&quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="kn">from</span> <span class="nn">..utils.spect</span> <span class="kn">import</span> <span class="n">spectrogram</span>

        <span class="n">spect</span><span class="p">,</span> <span class="n">spect_freq</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spectrogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">freq_range</span><span class="o">=</span><span class="n">freq_range</span><span class="p">)</span>
        <span class="n">spect_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">timestamp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">spect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># timestamp for spectrogram</span>
        <span class="k">return</span> <span class="n">spect_time</span><span class="p">,</span> <span class="n">spect</span><span class="p">,</span> <span class="n">spect_freq</span></div>

<div class="viewcode-block" id="AudioData.get_spectral_entropy"><a class="viewcode-back" href="../../analysis.html#analysis.spike.AudioData.get_spectral_entropy">[docs]</a>    <span class="k">def</span> <span class="nf">get_spectral_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spect</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate spectral entropy</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalize : bool</span>
<span class="sd">            Get normalized spectral entropy</span>
<span class="sd">        mode : {&#39;spectral&#39;, &#39;&#39;spectro_temporal&#39;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array of spectral entropy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.functions</span> <span class="kn">import</span> <span class="n">get_spectral_entropy</span>

        <span class="k">return</span> <span class="n">get_spectral_entropy</span><span class="p">(</span><span class="n">spect</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="NeuralData"><a class="viewcode-back" href="../../analysis.html#analysis.spike.NeuralData">[docs]</a><span class="k">class</span> <span class="nc">NeuralData</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">channel_nb</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;rhd&#39;</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">channel_nb</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="nb">format</span>  <span class="c1"># format of the file (e.g., rhd), this info should be in the database</span>

        <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;NeuralData_Ch</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span><span class="si">}</span><span class="s2">.npy&quot;</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">file_name</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>  <span class="c1"># if .npy doesn&#39;t exist or want to update the file</span>
            <span class="n">data_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_neural_data</span><span class="p">()</span>
            <span class="c1"># Save event_info as a numpy object</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="c1"># Set the dictionary values to class attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data_info</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data_info</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># print attributes</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

<div class="viewcode-block" id="NeuralData.load_neural_data"><a class="viewcode-back" href="../../analysis.html#analysis.spike.NeuralData.load_neural_data">[docs]</a>    <span class="k">def</span> <span class="nf">load_neural_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load and concatenate all neural data files (e.g., .rhd) in the input dir (path)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">..analysis.load</span> <span class="kn">import</span> <span class="n">read_rhd</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">sample_rate</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Load neural data&quot;</span><span class="p">)</span>
        <span class="c1"># List .rhd files</span>
        <span class="n">files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;*.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">))</span>

        <span class="c1"># Initialize</span>
        <span class="n">timestamp_concat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">amplifier_data_concat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Store values in these lists</span>
        <span class="n">file_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s1">&#39;cbin&#39;</span><span class="p">:</span>
            <span class="c1"># if the neural data is in .cbin format, read from .mat files that has contains concatenated data</span>
            <span class="c1"># currently does not have files to extract data from .cbin files in python</span>
            <span class="kn">import</span> <span class="nn">scipy.io</span>
            <span class="n">mat_file</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;*Ch</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span><span class="si">}</span><span class="s1">(merged).mat&#39;</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">timestamp_concat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">mat_file</span><span class="p">)[</span><span class="s1">&#39;t_amplifier&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">amplifier_data_concat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">mat_file</span><span class="p">)[</span><span class="s1">&#39;amplifier_data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Loop through Intan .rhd files</span>
            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>

                <span class="c1"># Load data file</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading... &#39;</span> <span class="o">+</span> <span class="n">file</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span>
                <span class="n">file_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">intan</span> <span class="o">=</span> <span class="n">read_rhd</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>  <span class="c1"># note that the timestamp is in second</span>
                <span class="c1"># Concatenate timestamps</span>
                <span class="n">intan</span><span class="p">[</span><span class="s1">&#39;t_amplifier&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="n">intan</span><span class="p">[</span><span class="s1">&#39;t_amplifier&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># start from t = 0</span>
                <span class="k">if</span> <span class="n">timestamp_concat</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">timestamp_concat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timestamp_concat</span><span class="p">,</span> <span class="n">intan</span><span class="p">[</span><span class="s1">&#39;t_amplifier&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">intan</span><span class="p">[</span><span class="s1">&#39;t_amplifier&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">timestamp_concat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">]))</span>
                    <span class="n">timestamp_concat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timestamp_concat</span><span class="p">,</span> <span class="n">intan</span><span class="p">[</span><span class="s1">&#39;t_amplifier&#39;</span><span class="p">])</span>

                <span class="c1"># Concatenate neural data</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">intan</span><span class="p">[</span><span class="s1">&#39;amplifier_channels&#39;</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;native_channel_name&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">:]):</span>
                        <span class="n">amplifier_data_concat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">amplifier_data_concat</span><span class="p">,</span> <span class="n">intan</span><span class="p">[</span><span class="s1">&#39;amplifier_data&#39;</span><span class="p">][</span><span class="n">ind</span><span class="p">,</span> <span class="p">:])</span>

            <span class="n">timestamp_concat</span> <span class="o">*=</span> <span class="mf">1E3</span>  <span class="c1"># convert to microsecond</span>

        <span class="c1"># Organize data into a dictionary</span>
        <span class="n">data_info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;files&#39;</span><span class="p">:</span> <span class="n">file_list</span><span class="p">,</span>
            <span class="s1">&#39;timestamp&#39;</span><span class="p">:</span> <span class="n">timestamp_concat</span><span class="p">,</span>
            <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">amplifier_data_concat</span><span class="p">,</span>
            <span class="s1">&#39;sample_rate&#39;</span><span class="p">:</span> <span class="n">sample_rate</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;NeuralData_Ch</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_nb</span><span class="si">}</span><span class="s2">.npy&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">data_info</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_info</span></div>

<div class="viewcode-block" id="NeuralData.extract"><a class="viewcode-back" href="../../analysis.html#analysis.spike.NeuralData.extract">[docs]</a>    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_range</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts data from the specified range</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_range : list</span>
<span class="sd">            list of time stamps [start, end]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        timestamp : arr</span>
<span class="sd">        data : arr</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">time_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">open_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">open_folder</span>

        <span class="n">open_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Correlogram"><a class="viewcode-back" href="../../analysis.html#analysis.spike.Correlogram">[docs]</a><span class="k">class</span> <span class="nc">Correlogram</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for correlogram analysis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">correlogram</span><span class="p">):</span>

        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">spk_corr_parm</span><span class="p">,</span> <span class="n">burst_hz</span>

        <span class="n">corr_center</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">correlogram</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># center of the correlogram</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">correlogram</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">],</span>
                                  <span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">],</span>
                                  <span class="n">spk_corr_parm</span><span class="p">[</span><span class="s1">&#39;bin_size&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peak_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">correlogram</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">correlogram</span><span class="p">))</span> <span class="o">-</span> <span class="n">corr_center</span><span class="p">))</span> <span class="o">+</span> <span class="n">corr_center</span>  <span class="c1"># index of the peak</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peak_latency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_ind</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peak_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_ind</span><span class="p">]</span>
            <span class="n">burst_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">corr_center</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="n">burst_hz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">corr_center</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">/</span> <span class="n">burst_hz</span><span class="p">),</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>  <span class="c1"># burst range in the correlogram</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">burst_index</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">burst_range</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">peak_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_latency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">burst_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># print attributes</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

<div class="viewcode-block" id="Correlogram.category"><a class="viewcode-back" href="../../analysis.html#analysis.spike.Correlogram.category">[docs]</a>    <span class="k">def</span> <span class="nf">category</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">correlogram_jitter</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get bursting category of a neuron based on autocorrelogram</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        correlogram_jitter : np.ndarray</span>
<span class="sd">            Random time-jittered correlogram for baseline setting</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Category of a neuron (&#39;Bursting&#39; or &#39;Nonbursting&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">corr_burst_crit</span>

        <span class="n">corr_mean</span> <span class="o">=</span> <span class="n">correlogram_jitter</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">corr_mean</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>

            <span class="n">corr_std</span> <span class="o">=</span> <span class="n">correlogram_jitter</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">upper_lim</span> <span class="o">=</span> <span class="n">corr_mean</span> <span class="o">+</span> <span class="p">(</span><span class="n">corr_std</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">lower_lim</span> <span class="o">=</span> <span class="n">corr_mean</span> <span class="o">-</span> <span class="p">(</span><span class="n">corr_std</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span> <span class="o">=</span> <span class="n">upper_lim</span>

            <span class="c1"># Check peak significance</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_value</span> <span class="o">&gt;</span> <span class="n">upper_lim</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_ind</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_latency</span> <span class="o">&lt;=</span> <span class="n">corr_burst_crit</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">category</span> <span class="o">=</span> <span class="s1">&#39;Bursting&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">category</span> <span class="o">=</span> <span class="s1">&#39;NonBursting&#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">category</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">category</span></div>

<div class="viewcode-block" id="Correlogram.plot_corr"><a class="viewcode-back" href="../../analysis.html#analysis.spike.Correlogram.plot_corr">[docs]</a>    <span class="k">def</span> <span class="nf">plot_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">time_bin</span><span class="p">,</span> <span class="n">correlogram</span><span class="p">,</span>
                  <span class="n">title</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">font_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                  <span class="n">peak_line_width</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                  <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">peak_line</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">baseline</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot correlogram</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : axis object</span>
<span class="sd">            axis to plot the figure</span>
<span class="sd">        time_bin : np.ndarray</span>
<span class="sd">        correlogram : np.ndarray</span>
<span class="sd">        title : str</span>
<span class="sd">        font_size : int</span>
<span class="sd">            title font size</span>
<span class="sd">        normalize : bool</span>
<span class="sd">            normalize the correlogram</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="kn">from</span> <span class="nn">..utils.draw</span> <span class="kn">import</span> <span class="n">remove_right_top</span>
        <span class="kn">from</span> <span class="nn">..utils.functions</span> <span class="kn">import</span> <span class="n">myround</span>

        <span class="k">if</span> <span class="n">correlogram</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">time_bin</span><span class="p">,</span> <span class="n">correlogram</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">baseline</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">correlogram</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
            <span class="nb">round</span><span class="p">(</span><span class="n">ymax</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ymax</span><span class="p">))])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
            <span class="n">remove_right_top</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">peak_line</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_ind</span><span class="p">):</span>
                <span class="c1"># peak_time_ind = np.where(self.time_bin == self.peak_latency)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_ind</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">peak_line_width</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">baseline</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">baseline</span><span class="o">.</span><span class="n">mean</span><span class="p">()):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BurstingInfo"><a class="viewcode-back" href="../../analysis.html#analysis.spike.BurstingInfo">[docs]</a><span class="k">class</span> <span class="nc">BurstingInfo</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ClassInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">input_context</span><span class="p">):</span>

        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">burst_hz</span>

        <span class="c1"># ClassInfo can be BaselineInfo, MotifInfo etc</span>
        <span class="k">if</span> <span class="n">input_context</span><span class="p">:</span>  <span class="c1"># select data based on social context</span>
            <span class="n">spk_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">spk_ts</span> <span class="k">for</span> <span class="n">spk_ts</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ClassInfo</span><span class="o">.</span><span class="n">spk_ts</span><span class="p">,</span> <span class="n">ClassInfo</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span>
                        <span class="n">context</span> <span class="o">==</span> <span class="n">input_context</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">duration_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">duration</span> <span class="k">for</span> <span class="n">duration</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ClassInfo</span><span class="o">.</span><span class="n">durations</span><span class="p">,</span> <span class="n">ClassInfo</span><span class="o">.</span><span class="n">contexts</span><span class="p">)</span> <span class="k">if</span>
                             <span class="n">context</span> <span class="o">==</span> <span class="n">input_context</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">input_context</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spk_list</span> <span class="o">=</span> <span class="n">ClassInfo</span><span class="o">.</span><span class="n">spk_ts</span>
            <span class="n">duration_list</span> <span class="o">=</span> <span class="n">ClassInfo</span><span class="o">.</span><span class="n">durations</span>

        <span class="c1"># Bursting analysis</span>
        <span class="n">burst_spk_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">burst_duration_arr</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">nb_bursts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nb_burst_spk_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">spks</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spk_list</span><span class="p">):</span>

            <span class="c1"># spk = bi.spk_ts[8]</span>
            <span class="n">isi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">spks</span><span class="p">)</span>  <span class="c1"># inter-spike interval</span>
            <span class="n">inst_fr</span> <span class="o">=</span> <span class="mf">1E3</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">spks</span><span class="p">)</span>  <span class="c1"># instantaneous firing rates (Hz)</span>
            <span class="n">bursts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inst_fr</span> <span class="o">&gt;=</span> <span class="n">burst_hz</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># burst index</span>

            <span class="c1"># Skip if no bursting detected</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bursts</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Get the number of bursts</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bursts</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bursts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">size</span>  <span class="c1"># check if the spikes occur in bursting</span>
            <span class="n">nb_bursts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nb_bursts</span><span class="p">,</span> <span class="n">bursts</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">temp</span><span class="p">)</span>

            <span class="c1"># Get burst onset</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bursts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">spk_ind</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Remove consecutive spikes in a burst and just get burst onset</span>

            <span class="n">burst_onset_ind</span> <span class="o">=</span> <span class="n">bursts</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">temp</span><span class="p">):</span>
                <span class="n">burst_spk_ind</span> <span class="o">=</span> <span class="n">spk_ind</span><span class="p">[</span><span class="n">spk_ind</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">burst_onset_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">burst_onset_ind</span><span class="p">,</span> <span class="n">burst_spk_ind</span><span class="p">)</span>

            <span class="c1"># Get burst offset index</span>
            <span class="n">burst_offset_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bursts</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bursts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bursts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if not successive spikes</span>
                    <span class="n">burst_offset_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">burst_offset_ind</span><span class="p">,</span> <span class="n">bursts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Need to add the subsequent spike time stamp since it is not included (burst is the difference between successive spike time stamps)</span>
            <span class="n">burst_offset_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">burst_offset_ind</span><span class="p">,</span> <span class="n">bursts</span><span class="p">[</span><span class="n">bursts</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">burst_onset</span> <span class="o">=</span> <span class="n">spks</span><span class="p">[</span><span class="n">burst_onset_ind</span><span class="p">]</span>
            <span class="n">burst_offset</span> <span class="o">=</span> <span class="n">spks</span><span class="p">[</span><span class="n">burst_offset_ind</span><span class="p">]</span>
            <span class="n">burst_spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spks</span><span class="p">[</span><span class="n">burst_onset_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">burst_offset_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">burst_duration_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">burst_duration_arr</span><span class="p">,</span> <span class="n">burst_offset</span> <span class="o">-</span> <span class="n">burst_onset</span><span class="p">)</span>

            <span class="c1"># Get the number of burst spikes</span>
            <span class="n">nb_burst_spks</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># note that it should always be greater than 1</span>

            <span class="k">if</span> <span class="n">nb_bursts</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bursts</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">nb_burst_spks</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="n">nb_burst_spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nb_burst_spks</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">bursts</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bursts</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">bursts</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bursts</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">nb_burst_spks</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">nb_burst_spks</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">nb_burst_spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nb_burst_spks</span><span class="p">)</span>
                            <span class="n">nb_burst_spks</span> <span class="o">=</span> <span class="mi">1</span>

                        <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">bursts</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">nb_burst_spks</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">nb_burst_spk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nb_burst_spks</span><span class="p">)</span>
            <span class="c1"># print(nb_burst_spk_list)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nb_burst_spk_list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spk_list</span> <span class="o">=</span> <span class="n">burst_spk_list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_burst_spk</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nb_burst_spk_list</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fraction</span> <span class="o">=</span> <span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">nb_burst_spk_list</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">spks</span><span class="p">)</span> <span class="k">for</span> <span class="n">spks</span> <span class="ow">in</span> <span class="n">spk_list</span><span class="p">]),</span> <span class="mi">3</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">burst_duration_arr</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># total duration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">nb_bursts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">duration_list</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1E3</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_nb_spk</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nb_burst_spk_list</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_duration</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">burst_duration_arr</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># mean duration</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># no burst spike detected</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spk_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_burst_spk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_nb_spk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># print attributes</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span></div>


<div class="viewcode-block" id="ISI"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ISI">[docs]</a><span class="k">class</span> <span class="nc">ISI</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class object for inter-spike interval analysis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isi</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        isi : array</span>
<span class="sd">            Inter-spike interval array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..analysis.parameters</span> <span class="kn">import</span> <span class="n">isi_win</span><span class="p">,</span> <span class="n">isi_scale</span><span class="p">,</span> <span class="n">isi_bin</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">isi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">isi</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="n">isi_bin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Peak latency of the ISI distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_latency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">max</span><span class="p">())))]</span>  <span class="c1"># in ms</span>
        <span class="c1"># Proportion of within-refractory period spikes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">within_ref_prop</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="c1"># CV of ISI</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

<div class="viewcode-block" id="ISI.plot"><a class="viewcode-back" href="../../analysis.html#analysis.spike.ISI.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span>
             <span class="o">*</span><span class="n">title</span><span class="p">,</span>
             <span class="n">font_size</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..utils.draw</span> <span class="kn">import</span> <span class="n">remove_right_top</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_bin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="c1"># ax.set_ylim([0, myround(math.ceil(ax.get_ylim()[1]), base=5)])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_latency</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (ms)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">font_size</span><span class="p">)</span>
        <span class="n">remove_right_top</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Jaerong Ahn.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>